# 我是如何用Node做前端国际化的

本文我们主要讲一下整个解决方案的思维，方案的核心的就是降低人工成本，使前端国际化偏向于自动化。


在讲之前，其实还有一个问题个人觉得还是需要提一下。因为我看过很多的国际化项目，每个项目经过国际化改造之后呢，组件中原本所有的中文全部变成了$t('ts.xxxx')。当然这是国际化会产生的一个很现实的结果。改造之后，这样的代码可以说对我们的后期维护来说其实是非常的痛苦的。代码可读性直线下降。前面我说了，这是一个很现实的结果，但是这不是一个必然的结果。所以，我肯定是不会让这个结果产生的。

::: warning Question
如何解决国际化改造之后造成代码可读性下降？
:::

废话不多说，简单的介绍一下我的思路吧。

## 封装翻译方法,指令
看到这里，其实大家就明白了我上面说的问题了。是的，我就是拿中文来做检索的。组件里的中文该怎么写还怎么写，不用改成翻译包里对应的key了。这样我们的的代码可读性就上来了。当然，我需要知道你那些中文是需要去翻译的。所以我封装了一个全局翻译的方法（$_i18n）和一个全局的翻译指令（v-ts）;

***v-ts 主要应用于template中，$_i18n主要应用于js中***

- v-ts: 该指令用以读取组件的innerText, 将innerText拿来跟语言包里的中文做对比，找出该中文对应的key，然后将找出的key传给i18n的$t方法，$t根据key做对应的翻译。v-ts也支持传入value。默认去取传入的value如果没有传value,就会去读取el的innerText。
- $_i18n: 该方法主思路跟v-ts一样，只不过v-ts是需要去读取自身el的innerText，而$_i18n函数则是依赖接收的参数，将需要翻译的中文作为参数传入。

如果你是一个对项目又深入思考的人，到这里其实你就该提出疑问了？这样呃的中文对比岂不是非常的呆板？只要中文稍微发生一点的变化岂不是就不能准确的翻译了？哪怕是多个空格，少一个标点符号，而且也不利于翻译包的复用啊，翻译包的体积也变大了，要翻译的内容也多了，这不是加大工作量了吗？

对于这个问题我可以肯定的回答你，你的疑问都是存在的。翻译包的体积变大我可以毫不避讳的讲，是必然会增大的，所以我们要考虑如何降低语言包录入这个工作量，后面我会给出解决方案。我们先来看一下如何减少满项目的去添加我们v-ts和$_i18n；

## 组件代理
组件代理的意义在哪里？组件代理的意义其实就是为了减少我们的工作量。我们不用去针对所有中文去加翻译方法。我们只需在组件内部，将需要做翻译的字段或者插槽，属性，以及一级子组件需要做翻译的地方我们统一的添加我们的翻译方法。

这里的组件不仅仅指的是我们自定义的组件，有时候为了方便，我们还要将我们的UI框架的组件进行代理。而且代理UI框架的组件才是最有效方法。无论你的自定义组件如何封装，只要你用到了UI框架的组件，最终都跑不过被我们代理的命运，一旦被我们代理，那么就可以植入我们封装好的$_i18n和v-ts;

简单的上几个代理的组件来看一下效果：

``` vue
// formItem组件，将所有的表单的label做翻译
<template>
  <FormItem v-bind="attrs" v-on="$listeners">
    <span
      slot="label"
      v-if="$attrs.label">
      {{$t($_i18n($attrs.label))}}
    </span>
  </FormItem>
</template>
<script>
import { FormModel } from 'ant-design-vue'
export default {
  name: 'a-form-model-item',
}
</script>

```

``` vue
// 代理input组件，翻译input的placeholder;
<template>
  <i-input
    v-bind="$attrs"
    v-model="curValue"
    v-on="listeners"
    @input="inputHandler"
    :placeholder="$_i18n(placeholder)">
    <template v-for="name in Object.keys($slots)" :slot="name">
      <slot :name="name"></slot>
    </template>
  </i-input>
</template>
<script>
import { Input } from 'ant-design-vue'
export default {
  name: 'a-input'
}
</script>
```
我这里使用的是 ***ant-design-vue*** UI 框架。然后我们将我们代理组件注册为全局组件，并根据 ***name*** 来覆盖UI组件的原来的组件。所以name我们一般取名跟UI 框架的组件名相同，以达到覆盖的效果。

还有很多的一些常用的组件，例如button,table等。

## 国际化语言包的收集
国际化翻译还有一个必然的条件，那就是国家化的语言包。上面我们谈到了语言包收集的工作量的问题。是的，如果你的项目达到一定规模的话，全部靠手动的维护，这势必是很耗时的。所以接下来要介绍的就是如果让这份工作自动化的方法。

### 语言包的excel导入
国际化的需求一般都是依赖于前端实现的，所以后段基本是不可指望的，但是我又不想一句句的手动录入。故，我们是时候另辟蹊径了。

当我接收这份工作的时候，我拿到了一根专业翻译的语言包excel。所以我的工作就是将这份专业的语言包excel录入到项目中。嗯，这是一份十分轻松但是无趣的工作，所以从一开始对手工录入的想法我是拒绝的。既然是excel，那我们何不利用excel导入呢？将导入的文件内容进行解析，根据国际化语言包的标准生成对应的json文件，写入到项目中。

说干就干，感谢webpack, 自带node和express,让我们省了很多事，没必要去另开一个node项目。我们就用自带的node,express来开启一份本地服务。express创建本地服务的方法我就不介绍了。

介绍一款基于node的excel文件解析的插件***node-xlsx***;

> npm install node-xlsx -D

贴一下代码，如何利用express来解析excel文件，并写入到项目本地的。
``` js
const express = require('express')
const app = express()
const fs = require('fs')
const path = require('path')
const xls =  require('node-xlsx')
const { resolve } = require('path')
const axios = require('axios')
app.listen(8090, () => {
  console.log('服务启动了')
})
//  node服务， server.js
app.get('/import', (req, res) => {
  // 读取项目/src/lang文件夹下的ts.xlsx文件（ts.xlsx文件就是上述的国际化语言包excel文件）
  const file = path.join(__dirname, '/src/lang/ts.xlsx')
  // 利用node-xlsx插件解析excel，sheetList为解析后的结果
  var sheetList = xls.parse(file)

  // 判断文件夹路径是否存在
  var pathIsExit = (path) => {
    return new Promise((resolve, reject) => {
      fs.access(path, (err) => {
        if (err) {
          resolve(false)
        } else {
          resolve(true)
        }
      })
    })
  }
  // 创建文件夹
  var makeDir = async (path) => {
    return new Promise((resolve, reject) => {
      fs.mkdir(path, (err) => {
        if (err) {
          resolve(false)
        } else {
          resolve(true)
        }
      })
    })
  }
  // 文件写入，node的writeFile还是很优秀的，如果文件不存在，会先创建文件，然后写入，如果文件存在就向文件写入内容。
  var writeFile = (path, content) => {
    fs.writeFile(path, content, 'utf8', (err) => {
      if (err) {
        console.log(err)
        return
      }
      console.log('文件写入成功')
    })
  }
  // 将解析的excel内容转换成语言包要求的标准格式的文件
  var createContent = async ({name, data}) => {
    var dir_path = path.join(__dirname, `/src/lang/${name}`)
    var zn_path = `${dir_path}/zh-CN.js`
    var en_path = `${dir_path}/en-US.js`
    var znJson = {}
    var enJson = {}
    data.forEach((e, index) => {
      var zn = e[0]
      var en = e[1]
      if (zn && en) {
        znJson[`${name}_${index}`] = zn.replace(/\\n/g, '').trim()
        enJson[`${name}_${index}`] = en.replace(/\\n/g, '').trim()
      }
    })
    var isExit = await pathIsExit(dir_path) // 先判断文件夹是否存在
    isExit || (isExit = await makeDir(dir_path)) // 不存在的话就先创建文件夹
    writeFile(zn_path, `export default ${JSON.stringify(znJson)}`) // 中文翻译包文件写入
    writeFile(en_path, `export default ${JSON.stringify(enJson)}`) // 英文翻译包文件写入
  }
  sheetList.forEach(e => {
    createContent(e)
  })
  res.json({code: 0, sheetList})
})
```
到这一步其实远远没有达到我们自动化的要求，虽然不用手动去项目中一句一句的录入了，但是excel里的翻译内容是也是需要人工的，虽然不需要我们去做，但是终归是需要人力去维护的。

所以，如果只到这一步，我们的系统就只能算是人工 + 智能了，而非人工智能。既然如此，能用代码解决我们就绝不动手。

## 百度翻译的接入
是的，我这里就是利用百度翻译的，来做国际化的。而且百度翻译也支持多种语言的翻译，我们只要根据需求去选择对应的语言就行。

[百度API](https://fanyi-api.baidu.com/doc/11)；

至于百度API接入我就不赘述了，有兴趣的自己去看看。

那么到这里就只剩一个问题了，如何侦测哪些中文是需要做翻译的，然后利用百度翻译的API进行翻译，然后将翻译的内容写入到对应的本地文件中。

上面，我们讲过了，利用我们封装的$_i18n和v-ts来对需要翻译的中文进行翻译，所以我们只需要做两件事。

1. 将所有需要翻译的中文的地方全部使用$_i18n和v-ts包裹
2. 在$_i18n方法和ts中侦测未翻译的中文，并存储下来，然后利用百度API进行翻译。

如何侦测中文是否未翻译：就是将要翻译的中文去已经翻译好的语言包中做比对，如果未找到，那就定义为未翻译。

::: warning Question
  为什么要将未翻译的中文缓存下来，而不是直接就调用好百度API进行翻译呢？
:::

其实，这是有两个考虑：
1. 百度API的限制，有访问频率限制，单位时间内，超过了频率将不能正确的翻译
2. 每次翻译完之后我们都要将翻译结果写入到文件项目中的，项目文件的变更会引起页面的热更新，如果频繁的更新，页面会一直处于闪烁的状态。

所以我们先将未翻译的中文缓存下来，然后进行批量翻译。

然后百度翻译有时候的翻译结果并不符合翻译预期，我们需要进行纠错，所以本人另外开发一个翻译纠错的页面。针对已翻译的语言包进行修改。

::: warning Question
1. 如何解决相同中文文案，不同页面需要不同的翻译文案的问题？
:::

答案肯定是有的：简单的提示一下，类似与命名空间的实现。

好了，本文着重的是讲解思路，如果需要了解更多详情的可以私聊我，提供全套的解决方案包括源码。


主要工具： node, express, node-xlsx, i18n






 