# Vue最佳实战-组件更新

## 路由切换，组件不变的三种解决方案
在使用vue开发项目有的时候，最常遇到的一个典型的问题就是，当页面切换到同一个路由，但参数不同的地址的时候，组件的生命周期钩子不会重新触发。
例如，路由如下情况：
``` js
const route = [
  {
    path: '/detail/:id',
    name: 'detail',
    component: Detail
  }
]
```
当我们从/detail/1切换到/detail/2的时候，组件是不会发生任何变化的。但是我们期望的是在路遇参数变化的时候可以重新根据路由参拉取新数据，重新渲染组件。
组件不会更新的原因是应为vue-router会识别出两个路由使用的是同一个组件，从而进行复用。并不会重新创建组件，因此组件的生命周期钩子函数自然不会被触发。

组件的本质是一个映射关系，所以先销毁在重新创建一个相同的组件会存在很大程度上的性能消耗，复用组件是正确的选择。**但这意味着，组件的生命周期钩子不会被重新触发**

我相信大家一定遇到过类似的场景，我为大家总结了三个方案，并说明优缺点，供大家选择。

## 路由导航守卫 beforeRouteUpdate

vue-router提供了组件导航守卫beforeRouteUpdate，该守卫在当前路由组件被复用的时候触发，可以我们可以利用这个导航守卫来解决问题。
我们可以将需要被重新执行的函数或逻辑放到这个钩子中，当钩子被执行的时候，里面的方法及逻辑当然也会被重新触发了。
这是我最推荐的方法。但是这样势必会造成代码的冗余。


## 监听路由对象（$route）的变化

通过watch来设置当前实例路由对象的变化，从而做出响应。例如：
``` js
watch: {
  $route () {
    // 执行需要调用的函数和逻辑
  }
}
```
这种方式可以解决上述问题，但是代价就是组件内多了一个watch，同时也会带来依赖追踪的内存消耗。
如果是您采用了这种解决方案，请将监听设置到具体的动态参数，而不是直接监听整个$route。这可以减少很多不必要的消耗。例如：
``` js
watch: {
  '$route.pramas.id' () {
    // 执行需要调用的函数和逻辑
  }
}
```
这种方式我再推荐进行一次改造，可以减少一些代码量。例如：
``` js
watch: {
  '$route.pramas.id': {
    handler () {
      // 执行需要调用的函数和逻辑
    },
    immediate: true //立即执行
  }
}
```
这样我们就没有必要在其他的钩子函数中再去写一次相同的业务逻辑了

## 为router-view组件添加key属性
这是一种取巧的方法，而且非常暴力。他的本质就是利用VDom在渲染时通过key来对比两个节点是否相同的原理。通过给router-view添加key属性，每次切换路由的时候，key发生改变，这会让VDom以为router-view是一个全新的节点，从而每次都会先去销毁组件，然后在重新创建组件。即使是相同的组件，如果url变了，key也就发生了变化，组件就会重新创建。例如：
``` js
<router-view :key="$route.fullPath"></router-view>
```
这种方式坏处很明显，每次路由切换组件都是被销毁然后重新创建，非常的浪费性能。优点就是简单粗暴，有效，代码改动最小。


